# Mutex and atomic
互斥锁就很好地解决了资源竞争问题，有人也把互斥锁叫做排它锁。
在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。

Mutex 是使用最广泛的同步原语（Synchronization primitives），有人也叫做并发原语。

<img src="./pics/Mutex.webp" />

在 Go 的标准库中，package sync 提供了锁相关的一系列同步原语，
这个 package 还定义了一个 Locker 的接口，Mutex 就实现了这个接口:
```
type Locker interface {
    Lock()
    Unlock()
}
```
当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。

详见[Mutex Demo](./mutex_test.go) 

## Mutex 常见的错误场景
Mutex 常见的错误场景有 4 类，分别是 
- Lock/Unlock 不是成对出现
- Copy 已使用的 Mutex
- 重入, Mutex 不是可重入的锁, 因为 Mutex 的实现中没有记录哪个 goroutine 拥有这把锁。理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件。
- 死锁

### 什么是可重入锁？
如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，就叫可重入锁（有时候也叫做递归锁）。
只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。

### 死锁的条件
死锁产生的必要条件。如果你想避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。
- 互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。
- 持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。
- 不可剥夺：资源只能由持有它的 goroutine 来释放。
- 环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。

错误示例1:
```
type Counter struct {
    sync.Mutex
    Count int
}


func main() {
    var c Counter
    c.Lock()
    defer c.Unlock()
    c.Count++
    foo(c) // 复制锁
}

// 这里Counter的参数是通过复制的方式传入的
func foo(c Counter) {
    c.Lock()
    defer c.Unlock()
    fmt.Println("in foo")
}
```
Package sync 的同步原语在使用后是不能复制适用的。
以 Mutex 来说，它是一个有状态的对象，它的 state 字段记录这个锁的状态。
如果你要复制一个已经加锁的 Mutex 给一个新的变量，那么新的刚初始化的变量居然被加锁了，这显然不符合你的期望，因为你期望的是一个零值的 Mutex

Go 在运行时，有死锁的检查机制，它能够发现死锁的 goroutine。
这个例子中因为复制了一个使用了的 Mutex，导致锁无法使用，程序处于死锁的状态。

如果不想运行的时候才发现这个因为复制 Mutex 导致的死锁问题，那么你怎么能够及时发现问题呢？
可以使用 vet 工具，把检查写在 Makefile 文件中，在持续集成的时候跑一跑，这样可以及时发现问题，及时修复。
我们可以使用 go vet 检查。

<br>

## Mutex原理
### 1. CAS
CAS 是实现互斥锁和同步原语的基础。

CAS 指令将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。
那啥是原子性呢？原子性保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS 会返回失败。


