# generic

## 泛型基本语法
```
func GenericFoo[P aConstraint, Q anotherConstraint](x,y P, z Q)
```
P、Q 是类型形参的名字，也就是类型。aConstraint，anotherConstraint 代表类型参数的约束（constraint），
我们可以理解为对类型参数可选值的一种限定。

从 GenericFoo 函数的声明中，我们可以看到，泛型函数的声明相比于普通函数多出了一个组成部分：类型参数列表。

## 约束
在 Go 泛型中，使用 interface 类型来定义约束。

为此，Go 接口类型的定义也进行了扩展，我们既可以声明接口的方法集合，也可以声明可用作类型实参的类型列表。
```

type C1 interface {
    ~int | ~int32
    M1()
}

type T struct{}
func (T) M1() {
}

type T1 int
func (T1) M1() {
}

func foo[P C1](t P)() {
}

func main() {
    var t1 T1
    foo(t1)
    var t T
    foo(t) // 编译器报错：T does not implement C1
}
```
在这段代码中，C1 是我们定义的约束，它声明了一个方法 M1，以及两个可用作类型实参的类型 (~int | ~int32)。
我们看到，类型列表中的多个类型实参类型用“|”分隔。

在这段代码中，我们还定义了两个自定义类型 T 和 T1，两个类型都实现了 M1 方法，但 T 类型的底层类型为 struct{}，
而 T1 类型的底层类型为 int，这样就导致了虽然 T 类型满足了约束 C1 的方法集合，
但类型 T 因为底层类型并不是 int 或 int32 而不满足约束 C1，这也就会导致foo(t)调用在编译阶段报错。

建议：做约束的接口类型与做传统接口的接口类型最好要分开定义，除非约束类型真的既需要方法集合，也需要类型列表。

<br>

## 性能
Go 泛型是否拖慢编译性能了呢？

不过，因为目前采用 Go 泛型重写的项目比较少，我们还没法举例对比，但Go 1.18 发布说明中给出了一个结论：Go 1.18 编译器的性能要比 Go 1.17 下降 15% 左右。不过，Go 核心团队也承诺将在 Go 1.19 中改善编译器的性能，这里也希望到时候的优化能抵消 Go 泛型带来的影响。


sort包：
- Go 标准库 sort 包（非泛型版）的 Ints 函数；
- Go 团队维护 golang.org/x/exp/slices 中的泛型版 Sort 函数；
- 对 golang.org/x/exp/slices 中的泛型版 Sort 函数进行改造得到的、仅针对[]int 进行排序的 Sort 函数。
泛型版和仅支持[]int 的 Sort 函数的性能是一致的，性能都要比目前标准库的 Ints 函数高出近一倍，并且在排序过程中没有额外的内存分配。由此我们可以得出结论：至少在这个例子中，泛型在运行时并未给算法带来额外的负担。

<br>

## 泛型的场景
适合使用范型的场景：

1. 首先，类型参数的一种有用的情况，就是当编写的函数的操作元素的类型为 slice、map、channel 等特定类型的时候。
如果一个函数接受这些类型的形参，并且函数代码没有对参数的元素类型作出任何假设，那么使用类型参数可能会非常有用。
在这种场合下，泛型方案可以替代反射方案，获得更高的性能。

2. 另一个适合使用类型参数的情况是编写通用数据结构。所谓的通用数据结构，指的是像切片或 map 这样，
但 Go 语言又没有提供原生支持的类型。比如一个链表或一个二叉树。
今天，需要这类数据结构的程序会使用特定的元素类型实现它们，或者是使用接口类型（interface{}）来实现。
不过，如果我们使用类型参数替换特定元素类型，可以实现一个更通用的数据结构，
这个通用的数据结构可以被其他程序复用。而且，用类型参数替换接口类型通常也会让数据存储的更为高效。

3. 在一些场合，使用类型参数替代接口类型，意味着代码可以避免进行类型断言（type assertion），
并且在编译阶段还可以进行全面的类型静态检查。


什么情况不宜使用泛型：

1. 如果你要对某一类型的值进行的全部操作，仅仅是在那个值上调用一个方法，请使用 interface 类型，而不是类型参数。
比如，io.Reader 易读且高效，没有必要像下面代码中这样使用一个类型参数像调用 Read 方法那样去从一个值中读取数据。
```
func ReadAll[reader io.Reader](r reader) ([]byte, error)  // 错误的作法
func ReadAll(r io.Reader) ([]byte, error)                 // 正确的作法
```
使用类型参数的原因是它们让你的代码更清晰，如果它们会让你的代码变得更复杂，就不要使用。

2. 当不同的类型使用一个共同的方法时，如果一个方法的实现对于所有类型都相同，就使用类型参数；
相反，如果每种类型的实现各不相同，请使用不同的方法，不要使用类型参数。

3. 如果你发现自己多次编写完全相同的代码（样板代码），各个版本之间唯一的差别是代码使用不同的类型，那就请你考虑是否可以使用类型参数。
反之，在你注意到自己要多次编写完全相同的代码之前，应该避免使用类型参数。